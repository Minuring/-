# 01 문제 해결 시작하기

## 📝 정리

### 1. 문제 해결과 프로그래밍 대회
- #### 프로그래밍 대회는 문제 해결 기술을 연마하기에 가장 좋은 방법이다.
  - 한국 정보 올림피아드
  - ACM-ICPC
  - 탑코더
  - 구글 코드잼


- #### 대회 준비를 위한 조언
  - 가능한 한 많은 문제 풀기
  - 가능한 한 많은 대회 참가하기
  - 온라인 채점 사이트 이용하기


### 2. 문제 해결 개관
- #### 문제 해결 과정
  1. 문제를 읽고 이해한다.
  2. 문제를 익숙한 용어로 재정의한다.
  3. 어떻게 해결할 지 계획을 세운다.
  4. 계획을 검증한다.
  5. 프로그램으로 구현한다.
  6. 어떻게 풀었는 지 돌아보고, 개선할 방법이 있는지 찾아본다.
  - 문제를 풀지 못할 때는 풀이를 참조하되, **반드시 복기한다.**


- #### 체계적인 접근을 위한 질문들
  - 비슷한 문제를 풀어본 적이 있던가?
  - 단순한 방법에서 시작할 수 없을까? 즉 무식하게 풀 수 있을까?
    - 의외로 단순히 해결되는 문제가 많고, 단순하게 풀고 개선해 나갈 수 있다.
  - 문제를 푸는 과정을 수식화할 수 있을까?
  - 문제를 단순화할 수 없을까?
  - 그림으로 그려볼 수 있을까?
  - 수식으로 표현할 수 있을까?
  - 문제를 분해할 수 있을까?
  - 뒤에서부터 생각해서 문제를 풀 수 있을까?
  - 순서를 강제할 수 있을까?
  - 특정 형태의 답만을 고려할 수 있을까?


#### 3. 코딩과 디버깅에 관하여
- #### 읽기 쉬운 코드를 작성하는 것이 매우 중요하다.
  - 간결한 코드를 작성하기
    - 단, 프로그래밍 대회에 있어서 전역변수 사용, 매크로 사용은 유용할 수 있다.
  - 적극적으로 코드 재사용하기
    - 단, 프로그래밍 대회에 있어서 단일책임을 엄격하게 지킬 필요는 없다.
  - 표준 라이브러리 공부하기
    - 자료구조, 정렬 등은 이미 검증된 표준 라이브러리를 사용하지 않을 이유가 없다.
  - 항상 같은 형태로 프로그램을 작성하기
  - 일관적이고 명료하게 이름짓기
    - 변수명, 함수명은 모호하지 않고 항상 **명료하게** 작성한다.
  - 모든 자료를 정규화해서 저장하기
    - 모든 분수를 기약분수로, 각도, 시간 등
  - 코드와 데이터를 분리하기
    - 1월~12월에 대한 문자열, 월마다 31일,28일,31일,, 등은 배열로 만들어두기


- #### 자주 하는 실수
  - 산술 오버플로
  - 배열 범위 밖 인덱스 접근 ( 0-based, 1-based )
  - 일관되지 않은 범위 표현 방식 사용하기
    - 대부분의 프로그래밍 언어는 첫 번째 값은 포함, 다른 하나는 포함하지 않는 반 열린 구간을 사용한다.
  - Off-by-one 오류
    - ex) 길이가 100미터, 10미터 간격 -> 11개
    - ex) A[i] ~ A[j] 평균은 j-i+1로 나누어야한다
  - 컴파일러가 잡아주지 못하는 상수 오타
  - 스택 오버플로
  - 다차원 배열 인덱스 순서 바꿔 쓰기
  - 잘못된 비교 함수 작성
    - 비교 연산자의 성질을 염두에 두어야한다. (집합 포함관계에서 유의)
  - 최대, 최소 예외 잘못 다루기
    - ex) 소수 판별에서 1과 2
  - 연산자 우선순위 잘못 쓰기
    - ex) 비트 연산자는 비교 연산자보다 우선순위가 낮다.
  - 너무 느린 입출력 방식 선택
    - 입출력의 양이 많으면 언어마다 빠른 방식을 사용해야한다.
  - 변수 초기화 문제
  
- #### 디버깅과 테스팅
  - 프로그래밍 대회에서 소스코드는 대개 짧으므로 **눈으로 디버깅하는 쪽이 훨씬 빠르다.**
  - 재귀 호출, 중복 반복문은 디버거로 디버깅하기에 적합하지 않다.
  - 눈으로 디버깅하기 힘든 코드는 애초에 코드를 복잡하게 짰다는 것이다.
  - 디버거 대신 작은 입력에대한 테스트, assertion, 중간 결과 출력을 하면 유용하다.
  - **스캐폴딩**은 코드의 정당성이나 반례를 찾는 데 유용하게 쓰인다.


- #### 변수 범위의 이해
  - 너무 큰 결과
  - 너무 큰 중간 값
  - 너무 큰 무한대 값
  - 해결법
    - 더 큰 자료형을 사용한다.
    - 연산의 순서를 바꾼다. ( 가능한 경우 )
    - 계산 방법을 바꾼다. ( 가능한 경우 ) ex)이항 계수
  - 자료형의 프로모션
    - 두 피연산자의 연산에 대해 적용되는 프로모션


- #### 실수 자료형의 이해
  - **컴퓨터는 실수를 근사적으로 표현한다.**
  - 실수 비교하기
    - 두 실수의 값이 같은 지 비교할 때는 항상 **오차를 염두에 두어야한다.**
    1. 비교할 실수의 크기들에 비례한 오차 한도를 정한다.
       - 같다고 판단해야 할 큰 값 두개(a,b)를 비교하는 경우
         - 오차한도값은 항상 |a-b| 보다 커야한다. 가능한 한 |a-b|의 최대치를 구하고 이보다 큰 오차 한도값 사용
       - 다르게 판단해야 하는 작은 값 두개를 비교하는 경우
         - ex) 동전의 반지름 >= 1, 소수점 아래 둘 째 자리까지 입력에 주어지는 경우
           - 반지름이 1인 원, 1.01인 원의 넓이 차 = 0.0201\pi  -> 오차 한도가 0.0001이하라면 충분히 안전
  
    2. 상대 오차를 이용한다.
       - 입력을 예측할 수 없을 때는 비교하는 숫자들의 크기에 비례하여 오차를 정해야한다.
       - 오차 허용범위는 비교하는 숫자에 비례한다.
       - 이 때 두 수의 절대 차이가 매우 작을 경우 같다고 판단할 필요가 있다.

  - 대소 비교하기
    - **항상 두 값이 아주 가까운 경우를 확인해야한다.**

  - 정확한 사칙연산
    - +-2^52 보다 절댓값이 작은 정수들, 분모가 2의 거듭제곱인 유리수들 등은 정확하게 표현 가능하다.
    - 자바의 BigDecimal 클래스 : 유리수 클래스
  
  - 코드의 수치적 안정성 파악하기
    - 실수 연산 오차가 정답과 얼마나 차이 나는 지, 이를 어떻게 줄일 지 생각해야한다.

  - 실수 연산 아예 하지 않기
    - 곱셈과 나눗셈의 순서 바꾸기
    - 양변 제곱하기
    - 최소공배수로 곱해서 정수 만들기